#!/bin/sh

# Copyright 2021 Grzesiek11
#
# Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 

# Internal functions

# backup_move PATH
backup_move() {
    dir="$backup_dir/$(dirname "$1")"
    mkdir -p "$dir"
    # Use cp instead of mv to allow merging directories. Could use -l option to create hardlinks and give cp the mv speed, but this might be unsafe.
    cp -ra "$target_dir/$1" "$dir"
    rm -rf "${target_dir:?}/$1"
}

# link PACKAGE
link() {
    stow_command() {
        # Don't use --dotfiles, even though it's cool - it's broken for directories (https://github.com/aspiers/stow/issues/33).
        stow --dir="$dot_dir/pkgs" --target="$target_dir" --stow "$1"
    }

    # Resolve conflicts with existing dotfiles by moving them to another directory.
    conflicts="$(stow_command "$1" 2>&1 | grep -Po '^  \* (existing target is neither a link nor a directory|existing target is not owned by stow): \K.+')"
    if [ -n "$conflicts" ]; then
        echo "$conflicts" | while IFS= read -r path; do
            backup_move "$path" || return 1
        done

        stow_command "$1" && return 0 || return 1
    else
        return 0
    fi
}

# unlink PACKAGE
unlink() {
    stow --dir="$dot_dir/pkgs" --target="$target_dir" --delete "$1" >/dev/null 2>&1
}

# package_info PACKAGE
package_info() {
    # shellcheck source=.dotman/pkg_scripts/base
    if [ -f "$dot_dir/.dotman/pkg_scripts/$1" ]; then
        eval "$(. "$dot_dir/.dotman/pkg_scripts/$1";
                echo pkg_description=\""$description"\";
                echo pkg_default=\""$default"\";
                echo pkg_always_honor=\""$always_honor"\";
                echo pkg_never_honor=\""$never_honor"\")"
        return 0
    else
        return 1
    fi
}

# Interface functions

# help EXIT_CODE
help() {
    cat <<EOF
Syntax: $0 [OPTION]... [SUBCOMMAND]
Local managment of synced dotfiles.

Options:
  -h            show this help message
  -V            show version information
  -v            be verbose

Subcommands:
  link          installs packages
  unlink        uninstalls packages
  relink        reinstalls packages
  update        updates the repository
  installer     interactive first-time setup
EOF

    exit "$1"
}

# version
version() {
    cat <<EOF
dotman v3.2.2
Created by Grzesiek11 (https://grzesiek11.stary.pc.pl)
Licensed under ISC: https://opensource.org/licenses/ISC

https://gitlab.com/grzesiek11/dotfiles
EOF

    exit 0
}

# not_implemented
not_implemented() {
    printf 'Sorry, this feature isn'\''t yet available.\n'
    
    exit 0
}

# action INIT_MSG SUCCESS_MSG FAIL_MSG COMMAND...
action() {
    init_msg="$1"
    success_msg="$2"
    fail_msg="$3"
    shift 3
    
    [ "$verbose" = 1 ] && printf '%b' "$init_msg"

    if "$@" >/tmp/dotman 2>&1; then
        [ "$verbose" = 1 ] && printf '%b' "$success_msg"
    else
        error=1; [ "$verbose" = 1 ] && printf '%b' "$fail_msg"
        return 1
    fi

    [ "$verbose" = 1 ] && cat /tmp/dotman
}

# sub_link
sub_link() {
    error=0

    for package in "$@"; do
        action "Linking $package..." '' ' getting package information failed.\n' package_info "$package" || continue
        
        # shellcheck disable=SC2154
        echo "$pkg_always_honor" | while IFS= read -r directory; do
            mkdir -p "$target_dir/$directory"
        done

        # shellcheck disable=SC2154
        echo "$pkg_never_honor" | while IFS= read -r directory; do
            [ -d "$directory" ] && backup_move "$directory"
        done

        action '' ' done.\n' ' linking failed.\n' link "$package"
    done

    return $error
}

# sub_unlink
sub_unlink() {
    error=0

    for package in "$@"; do
        action "Unlinking $package..." '' ' getting package information failed.\n' package_info "$package" || continue

        action '' '' ' unlinking failed.\n' unlink "$package" || continue

        # shellcheck disable=SC2154
        echo "$pkg_always_honor" | while IFS= read -r directory; do
            rm -d "$target_dir/$directory" 2>/dev/null
        done

        printf ' done.\n'
    done

    return $error
}

# sub_relink
sub_relink() {
    error=0
    
    for package in "$@"; do
        action '' '' '' sub_unlink "$package" || continue
        action '' '' '' sub_link "$package"
    done

    return $error
}

# sub_update
sub_update() {
    cd "$dot_dir" || return 1
    action 'Updating the repository...' ' done.\n' ' failed.\n' git pull || return 1
    action 'Updating submodules...' ' done.\n' ' failed.\n' git submodule update --depth=1 || return 1

    return 0
}

# sub_installer
sub_installer() {
    not_implemented
}

dot_dir="$(dirname "$(readlink -f "$0")")"
[ -f "$dot_dir/.dotman/config" ] && . "$dot_dir/.dotman/config"
[ -f "$dot_dir/.dotman/config.local" ] && . "$dot_dir/.dotman/config.local"
[ -z "$target_dir" ] && target_dir="$HOME"
[ -z "$backup_dir" ] && backup_dir="$dot_dir/backup"

verbose=0

while getopts 'hVv' opt; do
    case "$opt" in
        h)
            help 0
            ;;
        V)
            version
            ;;
        v)
            verbose=1
            ;;
        *)
            help 1
            ;;
    esac
done

shift $((OPTIND-1))

subcommand="$1"
[ -z "$subcommand" ] && help 1
shift 1

case "$subcommand" in
    link)
        sub_link "$@"
        exit
        ;;
    unlink)
        sub_unlink "$@"
        exit
        ;;
    relink)
        sub_relink "$@"
        exit
        ;;
    update)
        sub_update "$@"
        exit
        ;;
    installer)
        sub_installer "$@"
        exit
        ;;
    *)
        help 1
        ;;
esac
