#!/bin/sh

# Internal functions

# backup_move PATH
backup_move() {
    dir="$backup_dir/$(dirname "$1")"
    mkdir -p "$dir"
    # Use cp instead of mv to allow merging directories. Could use -l option to create hardlinks and give cp the mv speed, but this might be unsafe.
    cp -ra "$target_dir/$1" "$dir"
    rm -rfv "${target_dir:?}/$1"
}

# link PACKAGE
link() {
    stow_command() {
        # Don't use --dotfiles, even though it's cool - it's broken for directories (https://github.com/aspiers/stow/issues/33).
        stow --dir="$dot_dir/pkgs" --target="$target_dir" --stow "$1"
    }

    # Resolve conflicts with existing dotfiles by moving them to another directory.
    conflicts="$(stow_command "$1" 2>&1 | grep -Po '^  \* (existing target is neither a link nor a directory|existing target is not owned by stow): \K.+')"
    if [ -n "$conflicts" ]; then
        echo "$conflicts" | while IFS= read -r path; do
            backup_move "$path" || return 1
        done

        stow_command "$1" && return 0 || return 1
    else
        return 0
    fi
}

# unlink PACKAGE
unlink() {
    stow --dir="$dot_dir/pkgs" --target="$target_dir" --delete "$1" >/dev/null 2>&1
}

# package_info PACKAGE
package_info() {
    # shellcheck source=.dotman/pkg_scripts/base
    if [ -f "$dot_dir/.dotman/pkg_scripts/$1" ]; then
        eval "$(. "$dot_dir/.dotman/pkg_scripts/$1";
                echo pkg_description=\""$description"\";
                echo pkg_default=\""$default"\";
                echo pkg_always_honor=\""$always_honor"\";
                echo pkg_never_honor=\""$never_honor"\")"
        return 0
    else
        return 1
    fi
}

# Interface functions

# help EXIT_CODE
help() {
    cat <<EOF
Syntax: $0 [OPTION]... [SUBCOMMAND]
Local managment of synced dotfiles.

Options:
  -h            show this help message
  -V            show version information
  -v            be verbose

Subcommands:
  link          installs packages
  unlink        uninstalls packages
  relink        reinstalls packages
  update        updates the repository
  installer     interactive first-time setup
EOF

    exit "$1"
}

# version
version() {
    cat <<EOF
dotman v3.2
Created by Grzesiek11 (https://grzesiek11.stary.pc.pl)
Licensed under ISC: https://opensource.org/licenses/ISC

https://gitlab.com/grzesiek11/dotfiles
EOF
}

# not_implemented
not_implemented() {
    printf 'Sorry, this feature isn'\''t yet available.\n'
    
    exit 0
}

# action INIT_MSG SUCCESS_MSG FAIL_MSG COMMAND...
action() {
    init_msg="$1"
    success_msg="$2"
    fail_msg="$3"
    shift 3
    
    [ "$verbose" = 1 ] && printf '%b' "$init_msg"

    out="$("$@" 2>&1)" || { error=1; [ "$verbose" = 1 ] && printf '%b' "$fail_msg"; return 1; } && { [ "$verbose" = 1 ] && printf '%b' "$success_msg"; }

    [ "$verbose" = 1 ] && [ -n "$out" ] && echo "$out"
    return 0
}

# sub_link
sub_link() {
    error=0

    for package in "$@"; do
        action "Linking $package..." '' ' getting package information failed.\n' package_info "$package" || continue

        # shellcheck disable=SC2154
        echo "$pkg_always_honor" | while IFS= read -r directory; do
            mkdir -p "$target_dir/$directory"
        done

        # shellcheck disable=SC2154
        echo "$pkg_never_honor" | while IFS= read -r directory; do
            [ -d "$directory" ] && backup_move "$directory"
        done

        action '' ' done.\n' ' linking failed.\n' link "$package"
    done

    return $error
}

# sub_unlink
sub_unlink() {
    error=0

    for package in "$@"; do
        action "Unlinking $package..." '' ' getting package information failed.\n' package_info "$package" || continue

        action '' '' ' unlinking failed.\n' unlink "$package" || continue

        # shellcheck disable=SC2154
        echo "$pkg_always_honor" | while IFS= read -r directory; do
            rm -d "$target_dir/$directory" 2>/dev/null
        done

        printf ' done.\n'
    done

    return $error
}

# sub_relink
sub_relink() {
    error=0
    
    for package in "$@"; do
        action '' '' '' sub_unlink "$package" || continue
        action '' '' '' sub_link "$package"
    done

    return $error
}

# sub_update
sub_update() {
    cd "$dot_dir" || return 1
    action 'Updating the repository...' ' done.\n' ' failed.\n' git pull || return 1
    action 'Updating submodules...' ' done.\n' ' failed.\n' git submodule update || return 1

    return 0
}

# sub_installer
sub_installer() {
    not_implemented
}

dot_dir="$(dirname "$(readlink -f "$0")")"
[ -f "$dot_dir/.dotman/config" ] && . "$dot_dir/.dotman/config"
[ -f "$dot_dir/.dotman/config.local" ] && . "$dot_dir/.dotman/config.local"
[ -z "$target_dir" ] && target_dir="$HOME"
[ -z "$backup_dir" ] && backup_dir="$dot_dir/backup"

verbose=0

while getopts 'hVv' opt; do
    case "$opt" in
        h)
            help 0
            ;;
        V)
            version
            ;;
        v)
            verbose=1
            ;;
        *)
            help 1
            ;;
    esac
done

shift $((OPTIND-1))

subcommand="$1"
shift 1

case "$subcommand" in
    link)
        sub_link "$@"
        exit
        ;;
    unlink)
        sub_unlink "$@"
        exit
        ;;
    relink)
        sub_relink "$@"
        exit
        ;;
    update)
        sub_update "$@"
        exit
        ;;
    installer)
        sub_installer "$@"
        exit
        ;;
    *)
        help 1
        ;;
esac
